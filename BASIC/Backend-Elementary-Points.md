2.1 基础
★★★ 进程与线程的本质区别、以及各自的使用场景。

进程是什么
定义：
	1.进程是程序的一次执行 
	2.进程是一个程序及其数据在处理机上顺序执行时所发生的活动 
	3.进程是程序在一个数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位

进程的特征：

1.结构特征 
	进程实体由程序段，相关的数据段和PCB（progress control block）三部分构成程序实体。多数情况下说的进程实际上都是讲得进程实体。创建进程实际上是创建进程实体中的PCB，撤销进程也是撤销进程中的PCB 
2.动态性 
	看定义就知道，进程是程序的执行过程，必须不能是死的 
3.并发性 
	多个进程同存于内存中，能在一段时间内同时运行。具体参见创建进程的初衷 
4.独立性 
	能独立运行、独立分配资源和独立接受调用 
5.异步性 
	进程按各自独立的，不可预知的速度向前推进。或者说进程实体按异步方式运行



线程是什么 
	由于线程拥有许多进程所具有的特征，所以被称为轻型进程或者进程元。传统进程只拥有一个线程，在引入线程的操作系统中一般情况下一个进程会拥有若干个线程，至少一个。

进程与线程的区别


具体比较： 
1.调度 
	进程拥有资源 
	线程作为调度和分派的基本单位 
	同一进程中线程的切换不会引起进程的切换。 
	进程间的线程切换则会引起进程切换从而导致资源切换等 
2.并发性 
	进程：进程和进程之间可并发执行 
	线程：除了进程间的并发执行还可以线程之间并发执行 
	所以线程的并发性更高 
3.拥有资源 
	前面说了，线程并不能拥有资源，只有进程才拥有资源 
4.系统开销 
	进程创建、切换和撤销都会导致系统为之创建或者回收进程控制卡以及资源，但是线程的创建以及线程间的切换并不会引起系统做这些事儿，所以线程的系统开销明显更小。

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序 健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。


★☆☆ 进程状态。

进程的三种基本状态
1.就绪 
2.执行 
3.阻塞

★★★ 进程调度算法的特点以及使用场景。
	1.先进先出算法(FIFO)：按照进程进入就绪队列的先后次序来选择。即每当进入进程调度，总是把就绪队列的队首进程投入运行。

 

	2. 时间片轮转算法(RR)：分时系统的一种调度算法。轮转的基本思想是，将CPU的处理时间划分成一个个的时间片，就绪队列中的进程轮流运行一个时间片。当时间片结束时，就强迫进程让出CPU，该进程进入就绪队列，等待下一次调度，同时，进程调度又去选择就绪队列中的一个进程，分配给它一个时间片，以投入运行。

	3. 最高优先级算法(HPF)：进程调度每次将处理机分配给具有最高优先级的就绪进程。最高优先级算法可与不同的CPU方式结合形成可抢占式最高优先级算法和不可抢占式最高优先级算法。

1) 非抢占式优先权算法

在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。

2) 抢占式优先权调度算法

在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi>Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中


★☆☆ 线程实现的方式。
	见代码 pthread.h

★★☆ 协程的作用。
	
	实现一个用户态线程有两个必须要处理的问题：一是碰着阻塞式I\O会导致整个进程被挂起；二是由于缺乏时钟阻塞，进程需要自己拥有调度线程的能力。如果一种实现使得每个线程需要自己通过调用某个方法，主动交出控制权。那么我们就称这种用户态线程是协作式的，即是协程。

★★☆ 常见进程同步问题。
	https://blog.csdn.net/NeverWA/article/details/80722308

★★★ 进程通信方法的特点以及使用场景。


	1.无名管道简单方便．但局限于单向通信的工作方式．并且只能在创建它的进程及其子孙进程之间实现管道的共享：有名管道虽然可以提供给任意关系的进程使用．但是由于其长期存在于系统之中，使用不当容易出错。

	2.消息缓冲可以不再局限于父子进程．而允许任意进程通过共享消息队列来实现进程间通信．并由系统调用函数来实现消息发送和接收之间的同步．从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题．使用方便，但是信息的复制需要额外消耗CPU的时间．不适宜于信息量大或操作频繁的场合。

	3.共享内存针对消息缓冲的缺点改而利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。但是共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的．因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决。另外，由于内存实体存在于计算机系统中．所以只能由处于同一个计算机系统中的诸进程共享。不方便网络通信。

★★★ 死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁。
	互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。
	请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。
	非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
	循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。
	https://blog.csdn.net/ls5718/article/details/51896159

★★★ 虚拟内存的作用，分页系统实现虚拟内存原理。
	虚拟存储器的思想是程序、数据和堆栈的大小都有可能超过物理内存大小，由操作系统把当前使用的放在内存，而不需要的放在磁盘。

	1.当一个应用程序被启动时，操作系统就创建一个新进程，并给每个进程分配2gb的内存地址（不是内存只是地址）。

	2.虚拟内存管理器将应用程序的代码映射到那个程序的虚拟地址中得某个位置，并把当前所需的代码读取到物理地址中。

	3.如果使用动态链接库DLL，DLL也被映射到进程的虚拟地址空间，在需要的时候才被读入物理地址。

	4.其他项目（如数据，堆栈）的空间是从物理地址中分配的，并被映射到虚拟地址空间中。

	5.应用程序通过使用它的虚拟地址空间中的地址开始执行，然后虚拟内存管理器把每次的内存访问映射到物理位置。

★★★ 页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法。
	
	先进先出法：（置换次数比较多）
	最佳置换法（OPT）：选择将来不再使用或在最远的将来才被访问的页调换出去（不便于实现）
	最近最少使用置换法（LRU）:当需要置换一页时，选择在最近一段时间里最久没有使用过的页面予以淘汰
	最近未使用置换法（NUR）：是LRU算法的近似方法，选择在最近一段时间里未被访问过的页面予以淘汰

	LRU算法不仅考虑最近是否用过，还要考虑最近使用的频率。这里是基于过去的数据预测未来：如果一个页面被访问的频率低，那么以后很可能也用不到。

　　LRU算法的实现必须以某种方式记录每个页面被访问的次数，这是个相当大的工作量。最简单的方式就是在页表的记录项里增加一个计数域，一个页面被访问一次，这个计数器的值就增加1。于是，当需要更换页面时，只需要找到计数域值最小的页面替换即可，该页面即是最近最少使用的页面。另一种简单实现方式就是用一个链表将所有页面链接起来，最近被使用的页面在链表头，最近未被使用的放在链表尾。在每次页面访问时对这个链表进行更新，使其保持最近被使用的页面在链表头。


★★★ 比较分页与分段的区别。

	1)页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.

	2)页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.

	3)分页的作业地址空间是一维的.分段的地址空间是二维的.

★★★ 分析静态链接的不足，以及动态链接的特点。
	静态链接方法：#pragma comment(lib, "test.lib") ，静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来
	

	动态链接方法：LoadLibrary()/GetProcessAddress()和FreeLibrary()，使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序。

	动态库：

	1.共享：多个应用程序可以使用同一个动态库，启动多个应用程序的时候，只需要将动态库加载到内存一次即可；

	2.开发模块好：要求设计者对功能划分的比较好。

	 

	静态库：代码的装载速度快，执行速度也比较快，因为编译时它只会把你需要的那部分链接进去，应用程序相对比较大。但是如果多个应用程序使用的话，会被装载多次，浪费内存。

2.2 Linux
★★☆ 文件系统的原理，特别是 inode 和 block。数据恢复原理。
★★★ 硬链接与软链接的区别。
★★☆ 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。
★★★ 僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因。
